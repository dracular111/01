repeat task.wait() until game:IsLoaded()
local LocalPlayer = game:GetService('Players').LocalPlayer
repeat task.wait() until not LocalPlayer.PlayerGui:FindFirstChild('__INTRO')

_G.HW = _G.HW or {}
_G.HW.DebugMode = _G.HW.DebugMode or false
_G.HW.SwapInterval = _G.HW.SwapInterval or 1
_G.HW.ScanDebounce = _G.HW.ScanDebounce or 0.5
_G.HW.ClaimInterval = _G.HW.ClaimInterval or 5
_G.HW.PlaceEggInterval = _G.HW.PlaceEggInterval or 0.5
_G.HW.BaseWait = _G.HW.BaseWait or 0.5
_G.EggPillarCount = _G.EggPillarCount or 2

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService = game:GetService("TeleportService")
local player = Players.LocalPlayer
local Network = ReplicatedStorage:WaitForChild("Network")

local placeId = 131952481663528
if game.PlaceId ~= placeId then
    TeleportService:Teleport(placeId, player)
    return
end

task.spawn(function()
    pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/dracular111/01/main/V-AFK"))()
    end)
end)

task.spawn(function()
	wait(38)
    pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/dracular111/01/main/V-HOP-EV"))()
    end)
end)

task.spawn(function()
    wait(9)
    pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/dracular111/01/main/V-LowCPU"))()
    end)
end)

_G.PillarPets = _G.PillarPets or {}
_G.PillarScanDone = _G.PillarScanDone or false
_G.CurrentPlotId = _G.CurrentPlotId or nil
_G.CurrentPlotCFrame = _G.CurrentPlotCFrame or nil
_G.PillarTotalRateById = _G.PillarTotalRateById or {}
_G.PillarDisplayText = _G.PillarDisplayText or {}
_G.CurrentEggPillars = _G.CurrentEggPillars or {}
_G.WeakestPillarsFixed = _G.WeakestPillarsFixed or nil
_G.TotalRate = _G.TotalRate or 0

local function trim(s) return (s and s:gsub("^%s*(.-)%s*$", "%1")) or "" end
local function safeRequire(path)
    local ok, mod = pcall(function() return require(path) end)
    if ok then return mod end
    return nil
end

local function findPlayerPlot()
    local plotsFolder = workspace:FindFirstChild("__THINGS") and workspace.__THINGS:FindFirstChild("Plots")
    if not plotsFolder then return nil end
    for _, plot in pairs(plotsFolder:GetChildren()) do
        local buildFolder = plot:FindFirstChild("Build")
        if buildFolder and buildFolder:FindFirstChild("Sign") then
            local host = buildFolder.Sign:FindFirstChild("Host")
            if host and host:FindFirstChild("SurfaceGui") then
                local frame = host.SurfaceGui:FindFirstChild("Frame")
                if frame and frame:FindFirstChild("Title") then
                    if string.find(frame.Title.Text or "", player.Name) then
                        return plot
                    end
                end
            end
        end
    end
    return nil
end


task.spawn(function()
    while not _G.CurrentPlotId do
        local plot = findPlayerPlot()
        if plot then
            _G.CurrentPlotId = tonumber(plot.Name)
            local mainPart = plot:FindFirstChild("Main")
            if mainPart and mainPart:IsA("BasePart") then _G.CurrentPlotCFrame = mainPart.CFrame end
            break
        end
        task.wait(_G.HW.BaseWait)
    end
end)

task.spawn(function()
	local TeleportService = game:GetService("TeleportService")
	local Players = game:GetService("Players")
	local Workspace = game:GetService("Workspace")
	local player = Players.LocalPlayer
	local function safeTeleport()
		TeleportService:Teleport(game.PlaceId, player)
	end
	local character = player.Character or player.CharacterAdded:Wait()
	local hrp = character:WaitForChild("HumanoidRootPart")
	local humanoid = character:WaitForChild("Humanoid")
	repeat task.wait() until _G.CurrentPlotId
	local plot = Workspace.__THINGS.Plots:WaitForChild(tostring(_G.CurrentPlotId))
	local machine
	local startTime = tick()
	repeat
		task.wait()
		local inter = plot:FindFirstChild("Interactable")
		machine = inter and inter:FindFirstChild("Machines") and inter.Machines:FindFirstChild("HalloweenPetCraftingMachine")
	until (machine and machine:IsA("Model")) or tick() - startTime > 20
	if not machine then return safeTeleport() end
	local ok, pos = pcall(function() return machine:GetPivot().Position end)
	if not ok or not pos then return safeTeleport() end
	startTime = tick()
	while (hrp.Position - pos).Magnitude > 6 and tick() - startTime <= 20 do
		local target = pos + Vector3.new(0, 6, 0)
		if (hrp.Position - target).Magnitude > 6 then
			hrp.CFrame = CFrame.new(target)
		end
		task.wait(0.3)
	end
	if (hrp.Position - pos).Magnitude > 6 then
		safeTeleport()
	else
		task.wait(3)
		humanoid.PlatformStand = true
		hrp.Anchored = true
		local rng = Random.new()
		local randomOffset = Vector3.new(rng:NextInteger(-30,10), -30, rng:NextInteger(-30,10))
		hrp.CFrame = hrp.CFrame + randomOffset
		local platform = Instance.new("Part")
		platform.Size = Vector3.new(5,1,5)
		platform.CFrame = hrp.CFrame + Vector3.new(0,-5,0)
		platform.Anchored = true
		platform.Transparency = 1
		platform.CanCollide = true
		platform.Parent = Workspace
		_G.TeleDone = true
	end
end)

task.spawn(function()
    while true do
        pcall(function()
            for i = 1, 10 do
                Network.HalloweenWorld_Claim:InvokeServer(i)
            end
        end)
        task.wait(_G.HW.ClaimInterval)
    end
end)

local debrisFolder
local pillarsCFrames = {}
local scanScheduled = false
local DEBRIS_SCAN_LOCK = false
local function distance(v1, v2) return (v1 - v2).Magnitude end
local MAX_DISTANCE = 3

local function parseRateText(text)
    if not text then return 0 end
    local s = tostring(text):lower()
    s = s:gsub(",", "")
    local mult = 1
    if s:find("k") then mult = 1e3
    elseif s:find("m") then mult = 1e6
    elseif s:find("b") then mult = 1e9 end
    local num = tonumber((s:gsub("[^%d%.]", ""))) or 0
    return num * mult
end

local function findDebrisFolder()
    local f = workspace:FindFirstChild("__DEBRIS") or workspace:FindFirstChild("DEBRIS")
    if f then return f end
    for _, c in pairs(workspace:GetChildren()) do
        if type(c.Name) == "string" and string.match(string.lower(c.Name), "debris") then
            return c
        end
    end
    return nil
end

local function buildPillarsCFrames(plot)
    pillarsCFrames = {}
    local pillarsFolder = plot and plot:FindFirstChild("Interactable") and plot.Interactable:FindFirstChild("Pillars")
    if not pillarsFolder then return end
    for _, pillar in pairs(pillarsFolder:GetChildren()) do
        local baseTrim = pillar:FindFirstChild("BaseTrim")
        if baseTrim and baseTrim:IsA("BasePart") then
            local key = tonumber(pillar.Name) or pillar.Name
            pillarsCFrames[key] = baseTrim.CFrame
        end
    end
end

local previousPetCodes = {}
local function scanDebris()
    if DEBRIS_SCAN_LOCK then return end
    DEBRIS_SCAN_LOCK = true
    _G.PillarPets = {}
    if not debrisFolder then debrisFolder = findDebrisFolder() end
    if not debrisFolder then
        DEBRIS_SCAN_LOCK = false
        return
    end
    local PetByPillar = {}
    for _, petFolder in pairs(debrisFolder:GetChildren()) do
        local rootPart = petFolder:FindFirstChild("RootPart")
        if rootPart and rootPart:IsA("BasePart") then
            local petPos = rootPart.Position
            local nearestName, nearestDist = nil, math.huge
            for pname, pcf in pairs(pillarsCFrames) do
                local d = distance(petPos, pcf.Position)
                if d < nearestDist then nearestDist, nearestName = d, pname end
            end
            if nearestName and nearestDist <= MAX_DISTANCE then
                local displayText, rateText
                for _, d in ipairs(petFolder:GetDescendants()) do
                    if d:IsA("TextLabel") or d:IsA("TextBox") then
                        if not displayText and string.lower(d.Name):find("displayname") then displayText = d.Text end
                        if not rateText and string.lower(d.Name):find("rate") then rateText = d.Text end
                    elseif d:IsA("Frame") then
                        local dn = d:FindFirstChild("DisplayName")
                        local rt = d:FindFirstChild("Rate")
                        if dn and rt and dn:IsA("TextLabel") and rt:IsA("TextLabel") then
                            displayText = displayText or dn.Text
                            rateText = rateText or rt.Text
                            break
                        end
                    end
                end
                if displayText then
                    PetByPillar[nearestName] = PetByPillar[nearestName] or {}
                    table.insert(PetByPillar[nearestName], {
                        Name = displayText,
                        Rate = parseRateText(rateText),
                        CodeName = petFolder.Name
                    })
                end
            end
        end
    end
    for pid, _ in pairs(pillarsCFrames) do
        if not PetByPillar[pid] then PetByPillar[pid] = {} end
    end
    local changed = false
    for pid, pets in pairs(PetByPillar) do
        if not _G.CurrentEggPillars[pid] then
            local codes = {}
            for _, p in ipairs(pets) do table.insert(codes, p.CodeName) end
            table.sort(codes)
            local s = table.concat(codes, ",")
            if previousPetCodes[pid] ~= s then previousPetCodes[pid] = s; changed = true end
        end
    end
    if changed or not next(_G.PillarTotalRateById) then
        _G.PillarPets = PetByPillar
        _G.PillarTotalRateById = _G.PillarTotalRateById or {}
        local totalRate = 0
        for pid, pets in pairs(PetByPillar) do
            if not _G.CurrentEggPillars[pid] then
                local sum = 0
                for _, p in ipairs(pets) do sum = sum + (p.Rate or 0) end
                _G.PillarTotalRateById[pid] = sum
                totalRate = totalRate + sum
            else
                _G.PillarTotalRateById[pid] = _G.PillarTotalRateById[pid] or 0
                totalRate = totalRate + (_G.PillarTotalRateById[pid] or 0)
            end
        end
        _G.TotalRate = totalRate
        _G.PillarDisplayText = {}
        for pid, pets in pairs(_G.PillarPets) do
            if not _G.CurrentEggPillars[pid] then
                if #pets > 0 then
                    local names = {}
                    for _, p in ipairs(pets) do table.insert(names, p.Name) end
                    _G.PillarDisplayText[pid] = ("Pillar %s:\nPet: %s"):format(tostring(pid), table.concat(names, ", "))
                else
                    _G.PillarDisplayText[pid] = ("Pillar %s:\nPet: (trá»‘ng)"):format(tostring(pid))
                end
            end
        end
    end
    DEBRIS_SCAN_LOCK = false
    _G.PillarScanDone = true
end

local function scheduleScan()
    if scanScheduled then return end
    scanScheduled = true
    task.spawn(function()
        task.wait(_G.HW.ScanDebounce)
        scanScheduled = false
        scanDebris()
    end)
end

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.CurrentPlotId and _G.TeleDone
    local plotFolder = workspace:WaitForChild("__THINGS"):WaitForChild("Plots")
    local myPlot = plotFolder:FindFirstChild(tostring(_G.CurrentPlotId))
    if myPlot then buildPillarsCFrames(myPlot) end
    debrisFolder = findDebrisFolder()
    if debrisFolder then
        debrisFolder.ChildAdded:Connect(scheduleScan)
        debrisFolder.ChildRemoved:Connect(scheduleScan)
    end
    scheduleScan()
end)

task.spawn(function()
    task.wait(9)
    local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
    local SaveModule = nil
    while not SaveModule do
        SaveModule = safeRequire(Client.Save)
        if not SaveModule then task.wait(_G.HW.BaseWait) end
    end
    local function getCurrencyAmount(currencyId)
        local ok, data = pcall(function() return SaveModule.Get() end)
        if not ok or not data or not data.Inventory or not data.Inventory.Currency then return 0 end
        for _, v in pairs(data.Inventory.Currency) do
            if v.id == currencyId then return tonumber(v._am) or 0 end
        end
        return 0
    end
    local function rateCategory(totalRate)
        totalRate = tonumber(totalRate) or 0
        if totalRate >= 15000 then
            return 3
        elseif totalRate >= 10000 then
            return 2
        elseif totalRate >= 6000 then
            return 1
        else
            return 0
        end
    end
    local lastTier = nil
    local prevCategory = rateCategory(_G.TotalRate)
    repeat task.wait(_G.HW.BaseWait) until _G.PillarScanDone and _G.TeleDone
    while true do
        local candy = getCurrencyAmount("HalloweenCoins")
        local totalRate = tonumber(_G.TotalRate) or 0
        local currCategory = rateCategory(totalRate)
        if currCategory ~= prevCategory then
            lastTier = nil
        end
        local tier = lastTier or 1
        if totalRate >= 15000 then
            if tier == 5 then
                if candy < 15000000 then tier = 1 end
            else
                if candy >= 90000000 then tier = 5 end
            end
        elseif totalRate >= 10000 then
            if tier == 4 then
                if candy < 2400000 then tier = 3 end
            else
                if candy >= 10500000 then tier = 4 end
            end
        elseif totalRate >= 6000 then
            if tier == 3 then
                if candy < 50000 then tier = 1 end
            else
                if candy >= 500000 then tier = 3 end
            end
        else
            -- totalRate < 6000:
            if candy >= 30000000 then
                tier = 5
            elseif candy >= 5000000 then
                tier = 4
            elseif candy >= 500000 then
                tier = 3
            elseif candy >= 50000 then
                tier = 2
            else
                tier = 1
            end
        end
        lastTier = tier
        prevCategory = currCategory
        pcall(function()
            Network.Plots_Invoke:InvokeServer(_G.CurrentPlotId, "PurchaseEgg", tier, 3)
        end)
        task.wait(0.05)
    end
end)

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.PillarScanDone and _G.TeleDone
    local Client = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
    local SaveModule = safeRequire(Client.Save)
    while not SaveModule do task.wait(_G.HW.BaseWait); SaveModule = safeRequire(Client.Save) end
    local eggPriority = {"Coffin Egg","Reaper Egg","Spider Egg","Cauldron Egg","Ghost Egg","Bat Egg","Grave Egg","Pumpkin Egg"}
    local currentEgg = nil
    while true do
        local ok, saveData = pcall(function() return SaveModule.Get() end)
        if not ok or not saveData or not saveData.Inventory then
            task.wait(_G.HW.BaseWait)
        else
            local eggList = {}
            for _, v in pairs(saveData.Inventory.EggHalloween or {}) do
                if v.id then
                    local amount = (v._am and v._am > 0) and v._am or 1
                    eggList[v.id] = amount
                end
            end
            local bestEgg
            for _, name in ipairs(eggPriority) do if eggList[name] then bestEgg = name break end end
            if bestEgg then
                currentEgg = bestEgg
                for pid, _ in pairs(_G.PillarPets or {}) do _G.PillarTotalRateById[pid] = _G.PillarTotalRateById[pid] or 0 end
                if not _G.WeakestPillarsFixed then
                    local sorted = {}
                    for pid, total in pairs(_G.PillarTotalRateById) do table.insert(sorted, {id = pid, rate = total or 0}) end
                    table.sort(sorted, function(a,b) return a.rate < b.rate end)
                    local weakest = {}
                    for i=1, math.min(_G.EggPillarCount, #sorted) do table.insert(weakest, sorted[i].id) end
                    if #weakest > 0 then
                        _G.CurrentEggPillars = {}
                        for _, id in ipairs(weakest) do _G.CurrentEggPillars[id] = true end
                        _G.WeakestPillarsFixed = weakest
                    end
                end
                local weakest = _G.WeakestPillarsFixed or {}
                if #weakest > 0 then
                    for _, id in ipairs(weakest) do
                        pcall(function()
                            Network.HalloweenWorld_PlaceEgg:InvokeServer(id, currentEgg)
                        end)
                        task.wait(_G.HW.PlaceEggInterval)
                    end
                    for _, id in ipairs(weakest) do pcall(function() Network.HalloweenWorld_PickUp:InvokeServer(id) end); task.wait(_G.HW.BaseWait) end
                end
            else
                task.wait(_G.HW.BaseWait)
            end
        end
        task.wait(_G.HW.BaseWait)
    end
end)

local Rank = {
    ["Pumpkin Dog"] = 1, ["Skeleton Snake"] = 2, ["Zombie Pig"] = 3,
    ["Evil Raven"] = 4, ["Witch Wolf"] = 5, ["Mummy Cow"] = 6,
    ["Frankenpup Dog"] = 7, ["Devil Tasmanian"] = 8, ["Shark Cat"] = 9,
    ["Evil Kitsune"] = 10, ["Skelemelon"] = 11, ["Specter Owl"] = 12,
    ["Hacked Reaper"] = 13, ["Spectral Deer"] = 14, ["Vampire Agony"] = 15,
}
local function getPower(id, pt)
    local base = Rank[id] or 0
    local bonus = (pt or 0) * 3
    return base + bonus
end
local SaveModule = nil
local ClientLib = ReplicatedStorage:WaitForChild("Library"):WaitForChild("Client")
SaveModule = safeRequire(ClientLib.Save)
while not SaveModule do task.wait(_G.HW.BaseWait); SaveModule = safeRequire(ClientLib.Save) end
local function getBestPet()
    local ok, data = pcall(function() return SaveModule.Get() end)
    if not ok or not data or not data.Inventory then return {power=-1}, 0 end
    local Pets = data.Inventory.HPillar or {}
    local best = { power = -1 }
    local count = 0
    for uid, p in pairs(Pets) do
        if p and p.id then
            count = count + 1
            local power = getPower(p.id, p.pt)
            if power > best.power then
                best = { uid = uid, id = p.id, pt = p.pt or 0, _am = p._am or 1, power = power }
            end
        end
    end
    return best, count
end

local function getPillarPetsFromDisplay()
    local pillars = {}
    for name, text in pairs(_G.PillarDisplayText or {}) do
        local petName = text:match("Pet:%s*(.+)")
        if petName then
            petName = trim(petName)
            local pt = 0
            if petName:find("Rainbow") then pt = 2
            elseif petName:find("Golden") or petName:find("â­") then pt = 1 end
            petName = petName:gsub("Rainbow ", "") :gsub("Golden ", "") :gsub("â­ ", "") :gsub("ðŸŒˆ ", "")
            pillars[name] = { id = petName, pt = pt, power = getPower(petName, pt) }
        else
            pillars[name] = { id = "(trá»‘ng)", pt = 0, power = 0 }
        end
    end
    return pillars
end

local function isEggPillar(pillarName)
    if not _G.WeakestPillarsFixed then return false end
    for _, v in ipairs(_G.WeakestPillarsFixed) do if v == pillarName then return true end end
    return false
end

local function placePet(pillarId, newPetUid)
    if not pillarId or not newPetUid then return false end
    pcall(function() Network.HalloweenWorld_PickUp:InvokeServer(tonumber(pillarId)) end)
    task.wait(_G.HW.BaseWait)
    pcall(function() Network.HalloweenWorld_PlacePet:InvokeServer(tonumber(pillarId), newPetUid) end)
    return true
end

task.spawn(function()
    while not _G.WeakestPillarsFixed do task.wait(_G.HW.BaseWait) end
    while true do
        local best, count = getBestPet()
        if best and best.id then
            local currentPillars = getPillarPetsFromDisplay()
            for pillar, info in pairs(currentPillars) do
                if isEggPillar(pillar) then continue end
                if info.id == "(trá»‘ng)" or best.power > info.power then
                    placePet(tonumber(pillar), best.uid)
                    task.wait(_G.HW.BaseWait)
                end
            end
        end
        task.wait(_G.HW.SwapInterval)
    end
end)

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.CurrentPlotId and _G.TotalRate and _G.TeleDone
    local PlayerSave = safeRequire(ReplicatedStorage.Library.Client.Save)
    while not PlayerSave do task.wait(_G.HW.BaseWait); PlayerSave = safeRequire(ReplicatedStorage.Library.Client.Save) end
    local plotId = _G.CurrentPlotId
    local houseParam = 2
    local priority = {
        HalloweenCandyMultiplier = 10,
        HalloweenTrickOrTreatLuck = 10,
        HalloweenMoreWitchHats = 10,
        HalloweenMoreDiamonds = 10,
        HalloweenEggLuck = 10
    }
    local final = { HalloweenHugeLuck = 10, HalloweenTitanicLuck = 10 }
    local function getUpgrades()
        local u = {}
        local data = PlayerSave.Get().EventUpgrades or {}
        for k,_ in pairs(priority) do u[k] = data[k] or 0 end
        for k,_ in pairs(final) do u[k] = data[k] or 0 end
        return u
    end
    local function isMax(upgrades)
        for _,v in pairs(upgrades) do if v < 10 then return false end end
        return true
    end
    local function upgrade(key)
        pcall(function() Network:FindFirstChild("EventUpgrades: Purchase"):InvokeServer(key) end)
        task.wait(_G.HW.BaseWait)
    end
    while true do
        local totalRate = _G.TotalRate or 0
        if totalRate < 20000 then
            pcall(function() Network.Plots_Invoke:InvokeServer(plotId, "PurchaseHouse", houseParam) end)
            houseParam = houseParam < 5 and houseParam + 1 or 2
        end
        local u = getUpgrades()
        if not isMax(u) then
            for k, lvl in pairs(priority) do
                while (u[k] or 0) < lvl do upgrade(k); u[k] = u[k] + 1 end
            end
            for k, lvl in pairs(final) do
                while (u[k] or 0) < lvl do upgrade(k); u[k] = u[k] + 1 end
            end
        end
        if totalRate >= 20000 and isMax(u) then
            break
        end
        task.wait(_G.HW.BaseWait)
    end
end)

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.TotalRate and _G.TeleDone
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local PlayerSave = require(ReplicatedStorage.Library.Client.Save)
    local Network = ReplicatedStorage:WaitForChild("Network")
    local function craft(recipeIndex)
        local args = {
            [1] = "HalloweenPetCraftingMachine",
            [2] = recipeIndex,
            [3] = {
                ["shiny"] = false,
                ["pt"] = 0
            }
        }
        pcall(function()
            Network:FindFirstChild("HalloweenCraftingMachine_StartCraft"):InvokeServer(unpack(args))
        end)
        task.wait(5)
    end
    local function claimCraft(id)
        local args = { id }
        pcall(function()
            Network:FindFirstChild("HalloweenCraftingMachine_Claim"):InvokeServer(unpack(args))
        end)
        task.wait(5)
    end
    local function getCraftQueue()
        local data = PlayerSave.Get().HalloweenCraftingQueue or {}
        local ids = {}
        for id, v in pairs(data) do
            if v.Result and v.Result.Data and v.Result.Data.id then
                table.insert(ids, id)
            end
        end
        return ids
    end
    while task.wait(5) do
        local rate = _G.TotalRate or 0
        local queue = getCraftQueue()
        if #queue > 0 then
            for _, id in ipairs(queue) do
                claimCraft(id)
            end
        end
        if rate <= 50000 then
            craft(4) craft(3) craft(2) craft(1)
        else
            craft(4)
        end
    end
end)

task.spawn(function()
    repeat task.wait(_G.HW.BaseWait) until _G.TotalRate and _G.TeleDone
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Network = ReplicatedStorage.Network
    local PlayerSave = require(ReplicatedStorage.Library.Client.Save)
    local function getItemIdByName(invType, name)
        local inv = PlayerSave.Get().Inventory[invType]
        if not inv then return nil end
        for uid, data in pairs(inv) do
            if data.id == name then return uid end
        end
    end
    while task.wait(0.5) do
        local inv = PlayerSave.Get().Inventory
        local eggHave = false
        for _, data in pairs(inv.EggHalloween or {}) do
            if data.id == "Coffin Egg" or data.id == "Reaper Egg" then
                eggHave = true
                break
            end
        end
        local used = false
        if eggHave then
            local luckyEggId = getItemIdByName("Consumable", "Halloween Lucky Egg")
            local trickLuckId = getItemIdByName("Consumable", "Halloween Trick or Treat Luck")
            if luckyEggId then
                pcall(function()
                    Network.Consumables_Consume:InvokeServer(luckyEggId, 1)
                end)
                used = true
                task.wait(1)
            end
            if trickLuckId then
                pcall(function()
                    Network.Consumables_Consume:InvokeServer(trickLuckId, 1)
                end)
                used = true
            end
        end
        task.wait(used and 600 or 0.5)
    end
end)
