-- Ki·ªÉm tra bi·∫øn to√†n c·ª•c ƒë·ªÉ x√°c ƒë·ªãnh script ƒë√£ ch·∫°y hay ch∆∞a
if _G.WEBHOOKH then
    warn("Script ƒë√£ ƒë∆∞·ª£c ch·∫°y tr∆∞·ªõc ƒë√≥!")
    return -- D·ª´ng script n·∫øu ƒë√£ ch·∫°y
end

-- ƒê√°nh d·∫•u script ƒë√£ ƒë∆∞·ª£c ch·∫°y
_G.WEBHOOKH = true

getgenv().Webhook = {
    ['ID'] = "1263292904953217072",
    ['Id Names'] = { "Huge", "Titanic"},
    ['URL'] = "https://discord.com/api/webhooks/1345576741367971892/PIgN4hbFO5cOMXTbA85OSAXjRW86JaJCKbFTgEqiKPKzMmlVrJjYfekTFJpRMR4h1aeq",
}

repeat task.wait() until game:IsLoaded()
local LocalPlayer = game:GetService('Players').LocalPlayer
repeat task.wait() until not LocalPlayer.PlayerGui:FindFirstChild('__INTRO')

local Library = game.ReplicatedStorage.Library
local Client = Library.Client

local ExistCmds = require(Client.ExistCountCmds)
local RapCmds = require(Client.DevRAPCmds)
local Network = require(Client.Network)
local SaveMod = require(Client.Save)

-- ƒê·ªãnh d·∫°ng s·ªë l∆∞·ª£ng l·ªõn
local Formatint = function(int)
    local Suffix = {"", "k", "M", "B", "T", "Qd", "Qn", "Sx", "Sp", "Oc", "No", "De", "UDe", "DDe", "TDe", "QdDe", "QnDe", "SxDe", "SpDe", "OcDe", "NoDe", "Vg", "UVg", "DVg", "TVg", "QdVg", "QnVg", "SxVg", "SpVg", "OcVg", "NoVg", "Tg", "UTg", "DTg", "TTg", "QdTg", "QnTg", "SxTg", "SpTg", "OcTg", "NoTg", "QdAg", "QnAg", "SxAg", "SpAg", "OcAg", "NoAg", "e141", "e144", "e147", "e150", "e153", "e156", "e159", "e162", "e165", "e168", "e171", "e174", "e177", "e180", "e183", "e186", "e189", "e192", "e195", "e198", "e201", "e204", "e207", "e210", "e213", "e216", "e219", "e222", "e225", "e228", "e231", "e234", "e237", "e240", "e243", "e246", "e249", "e252", "e255", "e258", "e261", "e264", "e267", "e270", "e273", "e276", "e279", "e282", "e285", "e288", "e291", "e294", "e297", "e300", "e303"}
    local Index = 1
    
    if int < 999 then 
        return int
    end
    while int >= 1000 and Index < #Suffix do
        int = int / 1000
        Index = Index + 1
    end
    return string.format("%.2f%s", int, Suffix[Index])
end

-- H√†m g·ª≠i Webhook th√¥ng b√°o
local function SendWebhook(Class, Id, pt, sh)
    local Version = pt == 1 and "Golden " or pt == 2 and "Rainbow " or ""
    local ItemType = (Class == "Pet" and "Th√∫ c∆∞ng" or "Th·∫ª b√†i") -- Ph√¢n bi·ªát lo·∫°i

    local Title = string.format("||%s|| v·ª´a nh·∫≠n ƒë∆∞·ª£c **%s%s%s** (%s)", 
        LocalPlayer.Name, Version, sh and "Shiny " or "", Id, ItemType)

    -- N·∫øu l√† Card, ch·ªâ g·ª≠i webhook ƒë∆°n gi·∫£n
    if Class == "Card" then
        local Body = game:GetService("HttpService"):JSONEncode({
            content = string.format("<@%s>", Webhook['ID']),
            embeds = {
                {
                    title = Title,
                    color = 0xFF00FF,
                    timestamp = DateTime.now():ToIsoDate(),
                    footer = { text = "Heo Notifier" }
                }
            }
        })

        local success, err = pcall(function()
            return request({
                Url = Webhook['URL'],
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = Body
            })
        end)

        if not success then
            warn("Webhook g·ª≠i th·∫•t b·∫°i:", err)
        end
        return
    end

    -- N·∫øu kh√¥ng ph·∫£i Card, ti·∫øp t·ª•c l·∫•y h√¨nh ·∫£nh, RAP, Exist
    local Img = string.format("https://biggamesapi.io/image/%s", GetAsset(Id, pt))
    local Exist = GetStats(ExistCmds, Class, { id = Id, pt = pt, sh = sh, tn = nil })
    local Rap = GetStats(RapCmds, Class, { id = Id, pt = pt, sh = sh, tn = nil })

    local Body = game:GetService("HttpService"):JSONEncode({
        content = string.format("<@%s>", Webhook['ID']),
        embeds = {
            {
                title = Title,
                color = 0xFF00FF,
                timestamp = DateTime.now():ToIsoDate(),
                thumbnail = { url = Img },
                fields = {
                    { name = string.format("üíé Rap: ``%s`` \nüí´ Exist: ``%s``", Formatint(Rap or 0), Formatint(Exist or 0)), value = "" }
                },
                footer = { text = "Heo Notifier" }
            }
        }
    })

    local success, err = pcall(function()
        return request({
            Url = Webhook['URL'],
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = Body
        })
    end)

    if not success then
        warn("Webhook g·ª≠i th·∫•t b·∫°i:", err)
    end
end

-- L∆∞u s·ªë l∆∞·ª£ng Huge theo lo·∫°i
local HugeCount = {}

task.spawn(function()
    while true do
        -- L·∫•y inventory m·ªõi nh·∫•t
        local Inventory = SaveMod.Get()['Inventory']
        local CurrentCount = {}
        local NewHugeFound = false -- C·ªù ki·ªÉm tra c√≥ Huge m·ªõi kh√¥ng

        for Class, Items in pairs(Inventory) do
            -- Ki·ªÉm tra n·∫øu Class thu·ªôc danh s√°ch c·∫ßn theo d√µi (Pet / Card)
            if Class == "Pet" or Class == "Card" then
                for uid, v in pairs(Items) do
                    -- Ki·ªÉm tra n·∫øu item thu·ªôc danh s√°ch Huge / Titanic
                    for _, name in ipairs(Webhook['Id Names']) do
                        if string.find(v.id, name) then
                            -- C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng theo lo·∫°i
                            local Key = Class .. "_" .. v.id -- T·∫°o key ri√™ng cho t·ª´ng lo·∫°i
                            CurrentCount[Key] = (CurrentCount[Key] or 0) + 1

                            -- N·∫øu lo·∫°i n√†y nhi·ªÅu h∆°n l·∫ßn tr∆∞·ªõc, c√≥ item m·ªõi ho·∫∑c quay l·∫°i
                            if (HugeCount[Key] or 0) < CurrentCount[Key] then
                                SendWebhook(Class, v.id, v.pt, v.sh)
                                NewHugeFound = true
                            end
                        end
                    end
                end
            end
        end

        -- N·∫øu s·ªë l∆∞·ª£ng gi·∫£m, c·∫≠p nh·∫≠t l·∫°i nh∆∞ng kh√¥ng g·ª≠i Webhook
        for key, count in pairs(HugeCount) do
            if (CurrentCount[key] or 0) < count then
                HugeCount[key] = CurrentCount[key] or 0
            end
        end

        -- N·∫øu c√≥ item m·ªõi, c·∫≠p nh·∫≠t HugeCount
        if NewHugeFound then
            HugeCount = CurrentCount
        end

        -- ƒê·ª£i 5 gi√¢y tr∆∞·ªõc khi ki·ªÉm tra l·∫°i
        task.wait(5)
    end
end)
